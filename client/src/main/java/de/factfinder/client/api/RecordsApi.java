/*
 * FACT-Finder REST-API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package de.factfinder.client.api;

import de.factfinder.client.ApiCallback;
import de.factfinder.client.ApiClient;
import de.factfinder.client.ApiException;
import de.factfinder.client.ApiResponse;
import de.factfinder.client.Configuration;
import de.factfinder.client.Pair;
import de.factfinder.client.ProgressRequestBody;
import de.factfinder.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import de.factfinder.client.model.ApiError;
import de.factfinder.client.model.CompareResult;
import de.factfinder.client.model.CustomerPriceUpdateResult;
import de.factfinder.client.model.DeleteMarketRequest;
import de.factfinder.client.model.DeleteRequest;
import de.factfinder.client.model.DeleteResult;
import de.factfinder.client.model.DeltaUpdateResult;
import de.factfinder.client.model.DetailPage;
import de.factfinder.client.model.FlatRecordsResult;
import de.factfinder.client.model.FullRecordsResult;
import de.factfinder.client.model.GeoUpdateResult;
import de.factfinder.client.model.MarketUpdateResult;
import de.factfinder.client.model.MetaRequest;
import de.factfinder.client.model.RecommendationResultWithFieldRoles;
import de.factfinder.client.model.RecordMetaResult;
import de.factfinder.client.model.SimilarProductsWithFieldRoles;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class RecordsApi {
    private ApiClient localVarApiClient;

    public RecordsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public RecordsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    /**
     * Build call for compareUsingGET
     * @param channel channel (required)
     * @param idsOnly If the value true is passed, then only the record IDs will be returned, streamlining the results. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param id Use this parameter to pass product ID(s) which should be compared. (optional)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call compareUsingGETCall(String channel, Boolean idsOnly, List<String> id, String purchaserId, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v4/records/{channel}/compare"
            .replaceAll("\\{" + "channel" + "\\}", localVarApiClient.escapeString(channel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (idsOnly != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("idsOnly", idsOnly));
        }

        if (id != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "id", id));
        }

        if (purchaserId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("purchaserId", purchaserId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call compareUsingGETValidateBeforeCall(String channel, Boolean idsOnly, List<String> id, String purchaserId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling compareUsingGET(Async)");
        }
        

        okhttp3.Call localVarCall = compareUsingGETCall(channel, idsOnly, id, purchaserId, _callback);
        return localVarCall;

    }

    /**
     * Compare products
     * 
     * @param channel channel (required)
     * @param idsOnly If the value true is passed, then only the record IDs will be returned, streamlining the results. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param id Use this parameter to pass product ID(s) which should be compared. (optional)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @return CompareResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public CompareResult compareUsingGET(String channel, Boolean idsOnly, List<String> id, String purchaserId) throws ApiException {
        ApiResponse<CompareResult> localVarResp = compareUsingGETWithHttpInfo(channel, idsOnly, id, purchaserId);
        return localVarResp.getData();
    }

    /**
     * Compare products
     * 
     * @param channel channel (required)
     * @param idsOnly If the value true is passed, then only the record IDs will be returned, streamlining the results. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param id Use this parameter to pass product ID(s) which should be compared. (optional)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @return ApiResponse&lt;CompareResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<CompareResult> compareUsingGETWithHttpInfo(String channel, Boolean idsOnly, List<String> id, String purchaserId) throws ApiException {
        okhttp3.Call localVarCall = compareUsingGETValidateBeforeCall(channel, idsOnly, id, purchaserId, null);
        Type localVarReturnType = new TypeToken<CompareResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Compare products (asynchronously)
     * 
     * @param channel channel (required)
     * @param idsOnly If the value true is passed, then only the record IDs will be returned, streamlining the results. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param id Use this parameter to pass product ID(s) which should be compared. (optional)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call compareUsingGETAsync(String channel, Boolean idsOnly, List<String> id, String purchaserId, final ApiCallback<CompareResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = compareUsingGETValidateBeforeCall(channel, idsOnly, id, purchaserId, _callback);
        Type localVarReturnType = new TypeToken<CompareResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteCustomerPricesUsingDELETE
     * @param channel channel (required)
     * @param id The ids from the records which should be deleted. (optional)
     * @param idType Specifies which type of id is given. (optional, default to productNumber)
     * @param verbose verbose (optional, default to false)
     * @param deleteRequest deleteRequest (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteCustomerPricesUsingDELETECall(String channel, List<String> id, String idType, Boolean verbose, DeleteRequest deleteRequest, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = deleteRequest;

        // create path and map variables
        String localVarPath = "/rest/v4/records/{channel}/customerprices"
            .replaceAll("\\{" + "channel" + "\\}", localVarApiClient.escapeString(channel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (id != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "id", id));
        }

        if (idType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("idType", idType));
        }

        if (verbose != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("verbose", verbose));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteCustomerPricesUsingDELETEValidateBeforeCall(String channel, List<String> id, String idType, Boolean verbose, DeleteRequest deleteRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling deleteCustomerPricesUsingDELETE(Async)");
        }
        

        okhttp3.Call localVarCall = deleteCustomerPricesUsingDELETECall(channel, id, idType, verbose, deleteRequest, _callback);
        return localVarCall;

    }

    /**
     * Delete customer prices
     * 
     * @param channel channel (required)
     * @param id The ids from the records which should be deleted. (optional)
     * @param idType Specifies which type of id is given. (optional, default to productNumber)
     * @param verbose verbose (optional, default to false)
     * @param deleteRequest deleteRequest (optional)
     * @return List&lt;DeleteResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public List<DeleteResult> deleteCustomerPricesUsingDELETE(String channel, List<String> id, String idType, Boolean verbose, DeleteRequest deleteRequest) throws ApiException {
        ApiResponse<List<DeleteResult>> localVarResp = deleteCustomerPricesUsingDELETEWithHttpInfo(channel, id, idType, verbose, deleteRequest);
        return localVarResp.getData();
    }

    /**
     * Delete customer prices
     * 
     * @param channel channel (required)
     * @param id The ids from the records which should be deleted. (optional)
     * @param idType Specifies which type of id is given. (optional, default to productNumber)
     * @param verbose verbose (optional, default to false)
     * @param deleteRequest deleteRequest (optional)
     * @return ApiResponse&lt;List&lt;DeleteResult&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<DeleteResult>> deleteCustomerPricesUsingDELETEWithHttpInfo(String channel, List<String> id, String idType, Boolean verbose, DeleteRequest deleteRequest) throws ApiException {
        okhttp3.Call localVarCall = deleteCustomerPricesUsingDELETEValidateBeforeCall(channel, id, idType, verbose, deleteRequest, null);
        Type localVarReturnType = new TypeToken<List<DeleteResult>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete customer prices (asynchronously)
     * 
     * @param channel channel (required)
     * @param id The ids from the records which should be deleted. (optional)
     * @param idType Specifies which type of id is given. (optional, default to productNumber)
     * @param verbose verbose (optional, default to false)
     * @param deleteRequest deleteRequest (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteCustomerPricesUsingDELETEAsync(String channel, List<String> id, String idType, Boolean verbose, DeleteRequest deleteRequest, final ApiCallback<List<DeleteResult>> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteCustomerPricesUsingDELETEValidateBeforeCall(channel, id, idType, verbose, deleteRequest, _callback);
        Type localVarReturnType = new TypeToken<List<DeleteResult>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteGeoUsingDELETE
     * @param channel channel (required)
     * @param id The ids from the records which should be deleted. (optional)
     * @param verbose verbose (optional, default to false)
     * @param deleteRequest deleteRequest (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteGeoUsingDELETECall(String channel, List<String> id, Boolean verbose, DeleteRequest deleteRequest, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = deleteRequest;

        // create path and map variables
        String localVarPath = "/rest/v4/records/{channel}/geo"
            .replaceAll("\\{" + "channel" + "\\}", localVarApiClient.escapeString(channel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (id != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "id", id));
        }

        if (verbose != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("verbose", verbose));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteGeoUsingDELETEValidateBeforeCall(String channel, List<String> id, Boolean verbose, DeleteRequest deleteRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling deleteGeoUsingDELETE(Async)");
        }
        

        okhttp3.Call localVarCall = deleteGeoUsingDELETECall(channel, id, verbose, deleteRequest, _callback);
        return localVarCall;

    }

    /**
     * Delete geo data
     * 
     * @param channel channel (required)
     * @param id The ids from the records which should be deleted. (optional)
     * @param verbose verbose (optional, default to false)
     * @param deleteRequest deleteRequest (optional)
     * @return List&lt;DeleteResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public List<DeleteResult> deleteGeoUsingDELETE(String channel, List<String> id, Boolean verbose, DeleteRequest deleteRequest) throws ApiException {
        ApiResponse<List<DeleteResult>> localVarResp = deleteGeoUsingDELETEWithHttpInfo(channel, id, verbose, deleteRequest);
        return localVarResp.getData();
    }

    /**
     * Delete geo data
     * 
     * @param channel channel (required)
     * @param id The ids from the records which should be deleted. (optional)
     * @param verbose verbose (optional, default to false)
     * @param deleteRequest deleteRequest (optional)
     * @return ApiResponse&lt;List&lt;DeleteResult&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<DeleteResult>> deleteGeoUsingDELETEWithHttpInfo(String channel, List<String> id, Boolean verbose, DeleteRequest deleteRequest) throws ApiException {
        okhttp3.Call localVarCall = deleteGeoUsingDELETEValidateBeforeCall(channel, id, verbose, deleteRequest, null);
        Type localVarReturnType = new TypeToken<List<DeleteResult>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete geo data (asynchronously)
     * 
     * @param channel channel (required)
     * @param id The ids from the records which should be deleted. (optional)
     * @param verbose verbose (optional, default to false)
     * @param deleteRequest deleteRequest (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteGeoUsingDELETEAsync(String channel, List<String> id, Boolean verbose, DeleteRequest deleteRequest, final ApiCallback<List<DeleteResult>> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteGeoUsingDELETEValidateBeforeCall(channel, id, verbose, deleteRequest, _callback);
        Type localVarReturnType = new TypeToken<List<DeleteResult>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteMarketUsingDELETE
     * @param channel channel (required)
     * @param marketId The ids of the markets which should be deleted. (optional)
     * @param verbose verbose (optional, default to false)
     * @param deleteMarketRequest deleteMarketRequest (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteMarketUsingDELETECall(String channel, List<String> marketId, Boolean verbose, DeleteMarketRequest deleteMarketRequest, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = deleteMarketRequest;

        // create path and map variables
        String localVarPath = "/rest/v4/markets/{channel}"
            .replaceAll("\\{" + "channel" + "\\}", localVarApiClient.escapeString(channel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (marketId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "marketId", marketId));
        }

        if (verbose != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("verbose", verbose));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteMarketUsingDELETEValidateBeforeCall(String channel, List<String> marketId, Boolean verbose, DeleteMarketRequest deleteMarketRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling deleteMarketUsingDELETE(Async)");
        }
        

        okhttp3.Call localVarCall = deleteMarketUsingDELETECall(channel, marketId, verbose, deleteMarketRequest, _callback);
        return localVarCall;

    }

    /**
     * Delete geo market
     * 
     * @param channel channel (required)
     * @param marketId The ids of the markets which should be deleted. (optional)
     * @param verbose verbose (optional, default to false)
     * @param deleteMarketRequest deleteMarketRequest (optional)
     * @return List&lt;DeleteResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public List<DeleteResult> deleteMarketUsingDELETE(String channel, List<String> marketId, Boolean verbose, DeleteMarketRequest deleteMarketRequest) throws ApiException {
        ApiResponse<List<DeleteResult>> localVarResp = deleteMarketUsingDELETEWithHttpInfo(channel, marketId, verbose, deleteMarketRequest);
        return localVarResp.getData();
    }

    /**
     * Delete geo market
     * 
     * @param channel channel (required)
     * @param marketId The ids of the markets which should be deleted. (optional)
     * @param verbose verbose (optional, default to false)
     * @param deleteMarketRequest deleteMarketRequest (optional)
     * @return ApiResponse&lt;List&lt;DeleteResult&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<DeleteResult>> deleteMarketUsingDELETEWithHttpInfo(String channel, List<String> marketId, Boolean verbose, DeleteMarketRequest deleteMarketRequest) throws ApiException {
        okhttp3.Call localVarCall = deleteMarketUsingDELETEValidateBeforeCall(channel, marketId, verbose, deleteMarketRequest, null);
        Type localVarReturnType = new TypeToken<List<DeleteResult>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete geo market (asynchronously)
     * 
     * @param channel channel (required)
     * @param marketId The ids of the markets which should be deleted. (optional)
     * @param verbose verbose (optional, default to false)
     * @param deleteMarketRequest deleteMarketRequest (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteMarketUsingDELETEAsync(String channel, List<String> marketId, Boolean verbose, DeleteMarketRequest deleteMarketRequest, final ApiCallback<List<DeleteResult>> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteMarketUsingDELETEValidateBeforeCall(channel, marketId, verbose, deleteMarketRequest, _callback);
        Type localVarReturnType = new TypeToken<List<DeleteResult>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteUsingDELETE
     * @param channel channel (required)
     * @param id The ids from the records which should be deleted. (optional)
     * @param idType Specifies the type of id given. (optional, default to productNumber)
     * @param verbose verbose (optional, default to false)
     * @param deleteRequest deleteRequest (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteUsingDELETECall(String channel, List<String> id, String idType, Boolean verbose, DeleteRequest deleteRequest, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = deleteRequest;

        // create path and map variables
        String localVarPath = "/rest/v4/records/{channel}"
            .replaceAll("\\{" + "channel" + "\\}", localVarApiClient.escapeString(channel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (id != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "id", id));
        }

        if (idType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("idType", idType));
        }

        if (verbose != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("verbose", verbose));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteUsingDELETEValidateBeforeCall(String channel, List<String> id, String idType, Boolean verbose, DeleteRequest deleteRequest, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling deleteUsingDELETE(Async)");
        }
        

        okhttp3.Call localVarCall = deleteUsingDELETECall(channel, id, idType, verbose, deleteRequest, _callback);
        return localVarCall;

    }

    /**
     * Delete records
     * 
     * @param channel channel (required)
     * @param id The ids from the records which should be deleted. (optional)
     * @param idType Specifies the type of id given. (optional, default to productNumber)
     * @param verbose verbose (optional, default to false)
     * @param deleteRequest deleteRequest (optional)
     * @return List&lt;DeleteResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public List<DeleteResult> deleteUsingDELETE(String channel, List<String> id, String idType, Boolean verbose, DeleteRequest deleteRequest) throws ApiException {
        ApiResponse<List<DeleteResult>> localVarResp = deleteUsingDELETEWithHttpInfo(channel, id, idType, verbose, deleteRequest);
        return localVarResp.getData();
    }

    /**
     * Delete records
     * 
     * @param channel channel (required)
     * @param id The ids from the records which should be deleted. (optional)
     * @param idType Specifies the type of id given. (optional, default to productNumber)
     * @param verbose verbose (optional, default to false)
     * @param deleteRequest deleteRequest (optional)
     * @return ApiResponse&lt;List&lt;DeleteResult&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<DeleteResult>> deleteUsingDELETEWithHttpInfo(String channel, List<String> id, String idType, Boolean verbose, DeleteRequest deleteRequest) throws ApiException {
        okhttp3.Call localVarCall = deleteUsingDELETEValidateBeforeCall(channel, id, idType, verbose, deleteRequest, null);
        Type localVarReturnType = new TypeToken<List<DeleteResult>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete records (asynchronously)
     * 
     * @param channel channel (required)
     * @param id The ids from the records which should be deleted. (optional)
     * @param idType Specifies the type of id given. (optional, default to productNumber)
     * @param verbose verbose (optional, default to false)
     * @param deleteRequest deleteRequest (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteUsingDELETEAsync(String channel, List<String> id, String idType, Boolean verbose, DeleteRequest deleteRequest, final ApiCallback<List<DeleteResult>> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteUsingDELETEValidateBeforeCall(channel, id, idType, verbose, deleteRequest, _callback);
        Type localVarReturnType = new TypeToken<List<DeleteResult>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getCustomerPricesUsingGET
     * @param channel channel (required)
     * @param id The product numbers of the records for which customer prices should be returned. (required)
     * @param idType Specifies which type of id is given. (optional, default to productNumber)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCustomerPricesUsingGETCall(String channel, List<String> id, String idType, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v4/records/{channel}/customerprices"
            .replaceAll("\\{" + "channel" + "\\}", localVarApiClient.escapeString(channel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (idType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("idType", idType));
        }

        if (id != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "id", id));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCustomerPricesUsingGETValidateBeforeCall(String channel, List<String> id, String idType, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling getCustomerPricesUsingGET(Async)");
        }
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getCustomerPricesUsingGET(Async)");
        }
        

        okhttp3.Call localVarCall = getCustomerPricesUsingGETCall(channel, id, idType, _callback);
        return localVarCall;

    }

    /**
     * Get customer specific prices
     * 
     * @param channel channel (required)
     * @param id The product numbers of the records for which customer prices should be returned. (required)
     * @param idType Specifies which type of id is given. (optional, default to productNumber)
     * @return List&lt;Map&lt;String, Object&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public List<Map<String, Object>> getCustomerPricesUsingGET(String channel, List<String> id, String idType) throws ApiException {
        ApiResponse<List<Map<String, Object>>> localVarResp = getCustomerPricesUsingGETWithHttpInfo(channel, id, idType);
        return localVarResp.getData();
    }

    /**
     * Get customer specific prices
     * 
     * @param channel channel (required)
     * @param id The product numbers of the records for which customer prices should be returned. (required)
     * @param idType Specifies which type of id is given. (optional, default to productNumber)
     * @return ApiResponse&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Map<String, Object>>> getCustomerPricesUsingGETWithHttpInfo(String channel, List<String> id, String idType) throws ApiException {
        okhttp3.Call localVarCall = getCustomerPricesUsingGETValidateBeforeCall(channel, id, idType, null);
        Type localVarReturnType = new TypeToken<List<Map<String, Object>>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get customer specific prices (asynchronously)
     * 
     * @param channel channel (required)
     * @param id The product numbers of the records for which customer prices should be returned. (required)
     * @param idType Specifies which type of id is given. (optional, default to productNumber)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getCustomerPricesUsingGETAsync(String channel, List<String> id, String idType, final ApiCallback<List<Map<String, Object>>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCustomerPricesUsingGETValidateBeforeCall(channel, id, idType, _callback);
        Type localVarReturnType = new TypeToken<List<Map<String, Object>>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getDetailPageUsingGET
     * @param channel channel (required)
     * @param id The id for which the detailpage should be returned. (required)
     * @param idType Specifies which type of id is given. (optional, default to id)
     * @param idsOnly If the value true is passed, then only the record IDs will be returned, streamlining the results. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param maxResultsRecommendations Use this parameter to specify the number of recommendations you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 0)
     * @param maxResultsSimilarProducts Use this parameter to specify the number of similar articles you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 10)
     * @param usePersonalization Allows the activation/deactivation of the personalization of queries. true &#x3D; the search result will be personalized if the personalization module is activated and all other requirements are met; false &#x3D; the search result will not be personalized. (optional, default to true)
     * @param sid This parameter is used to pass an id for the user session. This is important for recognising the user, if you want to trigger personalised campaigns, as well as for FACT-Finder tracking. (optional)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param latitude The latitude coordinate of the current location. (optional)
     * @param longitude The longitude coordinate of the current location. (optional)
     * @param marketIds Currently selected markets (optional)
     * @param maxCountVariants The maximum number of variants to return for every record (optional, default to 5)
     * @param withCampaigns withCampaigns (optional, default to true)
     * @param withRecommendations withRecommendations (optional, default to true)
     * @param withSimilarProducts withSimilarProducts (optional, default to true)
     * @param withRecord withRecord (optional, default to true)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getDetailPageUsingGETCall(String channel, String id, String idType, Boolean idsOnly, Integer maxResultsRecommendations, Integer maxResultsSimilarProducts, Boolean usePersonalization, String sid, String purchaserId, Double latitude, Double longitude, List<String> marketIds, Integer maxCountVariants, Boolean withCampaigns, Boolean withRecommendations, Boolean withSimilarProducts, Boolean withRecord, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v4/detail/{channel}/{id}"
            .replaceAll("\\{" + "channel" + "\\}", localVarApiClient.escapeString(channel.toString()))
            .replaceAll("\\{" + "id" + "\\}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (idType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("idType", idType));
        }

        if (idsOnly != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("idsOnly", idsOnly));
        }

        if (maxResultsRecommendations != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxResultsRecommendations", maxResultsRecommendations));
        }

        if (maxResultsSimilarProducts != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxResultsSimilarProducts", maxResultsSimilarProducts));
        }

        if (usePersonalization != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("usePersonalization", usePersonalization));
        }

        if (sid != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sid", sid));
        }

        if (purchaserId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("purchaserId", purchaserId));
        }

        if (latitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("latitude", latitude));
        }

        if (longitude != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("longitude", longitude));
        }

        if (marketIds != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "marketIds", marketIds));
        }

        if (maxCountVariants != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxCountVariants", maxCountVariants));
        }

        if (withCampaigns != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("withCampaigns", withCampaigns));
        }

        if (withRecommendations != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("withRecommendations", withRecommendations));
        }

        if (withSimilarProducts != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("withSimilarProducts", withSimilarProducts));
        }

        if (withRecord != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("withRecord", withRecord));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getDetailPageUsingGETValidateBeforeCall(String channel, String id, String idType, Boolean idsOnly, Integer maxResultsRecommendations, Integer maxResultsSimilarProducts, Boolean usePersonalization, String sid, String purchaserId, Double latitude, Double longitude, List<String> marketIds, Integer maxCountVariants, Boolean withCampaigns, Boolean withRecommendations, Boolean withSimilarProducts, Boolean withRecord, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling getDetailPageUsingGET(Async)");
        }
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getDetailPageUsingGET(Async)");
        }
        

        okhttp3.Call localVarCall = getDetailPageUsingGETCall(channel, id, idType, idsOnly, maxResultsRecommendations, maxResultsSimilarProducts, usePersonalization, sid, purchaserId, latitude, longitude, marketIds, maxCountVariants, withCampaigns, withRecommendations, withSimilarProducts, withRecord, _callback);
        return localVarCall;

    }

    /**
     * Get the detail page
     * 
     * @param channel channel (required)
     * @param id The id for which the detailpage should be returned. (required)
     * @param idType Specifies which type of id is given. (optional, default to id)
     * @param idsOnly If the value true is passed, then only the record IDs will be returned, streamlining the results. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param maxResultsRecommendations Use this parameter to specify the number of recommendations you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 0)
     * @param maxResultsSimilarProducts Use this parameter to specify the number of similar articles you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 10)
     * @param usePersonalization Allows the activation/deactivation of the personalization of queries. true &#x3D; the search result will be personalized if the personalization module is activated and all other requirements are met; false &#x3D; the search result will not be personalized. (optional, default to true)
     * @param sid This parameter is used to pass an id for the user session. This is important for recognising the user, if you want to trigger personalised campaigns, as well as for FACT-Finder tracking. (optional)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param latitude The latitude coordinate of the current location. (optional)
     * @param longitude The longitude coordinate of the current location. (optional)
     * @param marketIds Currently selected markets (optional)
     * @param maxCountVariants The maximum number of variants to return for every record (optional, default to 5)
     * @param withCampaigns withCampaigns (optional, default to true)
     * @param withRecommendations withRecommendations (optional, default to true)
     * @param withSimilarProducts withSimilarProducts (optional, default to true)
     * @param withRecord withRecord (optional, default to true)
     * @return DetailPage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public DetailPage getDetailPageUsingGET(String channel, String id, String idType, Boolean idsOnly, Integer maxResultsRecommendations, Integer maxResultsSimilarProducts, Boolean usePersonalization, String sid, String purchaserId, Double latitude, Double longitude, List<String> marketIds, Integer maxCountVariants, Boolean withCampaigns, Boolean withRecommendations, Boolean withSimilarProducts, Boolean withRecord) throws ApiException {
        ApiResponse<DetailPage> localVarResp = getDetailPageUsingGETWithHttpInfo(channel, id, idType, idsOnly, maxResultsRecommendations, maxResultsSimilarProducts, usePersonalization, sid, purchaserId, latitude, longitude, marketIds, maxCountVariants, withCampaigns, withRecommendations, withSimilarProducts, withRecord);
        return localVarResp.getData();
    }

    /**
     * Get the detail page
     * 
     * @param channel channel (required)
     * @param id The id for which the detailpage should be returned. (required)
     * @param idType Specifies which type of id is given. (optional, default to id)
     * @param idsOnly If the value true is passed, then only the record IDs will be returned, streamlining the results. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param maxResultsRecommendations Use this parameter to specify the number of recommendations you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 0)
     * @param maxResultsSimilarProducts Use this parameter to specify the number of similar articles you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 10)
     * @param usePersonalization Allows the activation/deactivation of the personalization of queries. true &#x3D; the search result will be personalized if the personalization module is activated and all other requirements are met; false &#x3D; the search result will not be personalized. (optional, default to true)
     * @param sid This parameter is used to pass an id for the user session. This is important for recognising the user, if you want to trigger personalised campaigns, as well as for FACT-Finder tracking. (optional)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param latitude The latitude coordinate of the current location. (optional)
     * @param longitude The longitude coordinate of the current location. (optional)
     * @param marketIds Currently selected markets (optional)
     * @param maxCountVariants The maximum number of variants to return for every record (optional, default to 5)
     * @param withCampaigns withCampaigns (optional, default to true)
     * @param withRecommendations withRecommendations (optional, default to true)
     * @param withSimilarProducts withSimilarProducts (optional, default to true)
     * @param withRecord withRecord (optional, default to true)
     * @return ApiResponse&lt;DetailPage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<DetailPage> getDetailPageUsingGETWithHttpInfo(String channel, String id, String idType, Boolean idsOnly, Integer maxResultsRecommendations, Integer maxResultsSimilarProducts, Boolean usePersonalization, String sid, String purchaserId, Double latitude, Double longitude, List<String> marketIds, Integer maxCountVariants, Boolean withCampaigns, Boolean withRecommendations, Boolean withSimilarProducts, Boolean withRecord) throws ApiException {
        okhttp3.Call localVarCall = getDetailPageUsingGETValidateBeforeCall(channel, id, idType, idsOnly, maxResultsRecommendations, maxResultsSimilarProducts, usePersonalization, sid, purchaserId, latitude, longitude, marketIds, maxCountVariants, withCampaigns, withRecommendations, withSimilarProducts, withRecord, null);
        Type localVarReturnType = new TypeToken<DetailPage>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get the detail page (asynchronously)
     * 
     * @param channel channel (required)
     * @param id The id for which the detailpage should be returned. (required)
     * @param idType Specifies which type of id is given. (optional, default to id)
     * @param idsOnly If the value true is passed, then only the record IDs will be returned, streamlining the results. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param maxResultsRecommendations Use this parameter to specify the number of recommendations you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 0)
     * @param maxResultsSimilarProducts Use this parameter to specify the number of similar articles you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 10)
     * @param usePersonalization Allows the activation/deactivation of the personalization of queries. true &#x3D; the search result will be personalized if the personalization module is activated and all other requirements are met; false &#x3D; the search result will not be personalized. (optional, default to true)
     * @param sid This parameter is used to pass an id for the user session. This is important for recognising the user, if you want to trigger personalised campaigns, as well as for FACT-Finder tracking. (optional)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param latitude The latitude coordinate of the current location. (optional)
     * @param longitude The longitude coordinate of the current location. (optional)
     * @param marketIds Currently selected markets (optional)
     * @param maxCountVariants The maximum number of variants to return for every record (optional, default to 5)
     * @param withCampaigns withCampaigns (optional, default to true)
     * @param withRecommendations withRecommendations (optional, default to true)
     * @param withSimilarProducts withSimilarProducts (optional, default to true)
     * @param withRecord withRecord (optional, default to true)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getDetailPageUsingGETAsync(String channel, String id, String idType, Boolean idsOnly, Integer maxResultsRecommendations, Integer maxResultsSimilarProducts, Boolean usePersonalization, String sid, String purchaserId, Double latitude, Double longitude, List<String> marketIds, Integer maxCountVariants, Boolean withCampaigns, Boolean withRecommendations, Boolean withSimilarProducts, Boolean withRecord, final ApiCallback<DetailPage> _callback) throws ApiException {

        okhttp3.Call localVarCall = getDetailPageUsingGETValidateBeforeCall(channel, id, idType, idsOnly, maxResultsRecommendations, maxResultsSimilarProducts, usePersonalization, sid, purchaserId, latitude, longitude, marketIds, maxCountVariants, withCampaigns, withRecommendations, withSimilarProducts, withRecord, _callback);
        Type localVarReturnType = new TypeToken<DetailPage>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFullRecordsUsingGET
     * @param channel channel (required)
     * @param id The record ids of the records which should be returned (required)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param idType Specifies which type of id is given. (optional, default to id)
     * @param maxCountVariants The maximum number of variants to return for every record (optional, default to 5)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFullRecordsUsingGETCall(String channel, List<String> id, String purchaserId, String idType, Integer maxCountVariants, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v4/records/{channel}/full"
            .replaceAll("\\{" + "channel" + "\\}", localVarApiClient.escapeString(channel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (id != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "id", id));
        }

        if (purchaserId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("purchaserId", purchaserId));
        }

        if (idType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("idType", idType));
        }

        if (maxCountVariants != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxCountVariants", maxCountVariants));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFullRecordsUsingGETValidateBeforeCall(String channel, List<String> id, String purchaserId, String idType, Integer maxCountVariants, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling getFullRecordsUsingGET(Async)");
        }
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getFullRecordsUsingGET(Async)");
        }
        

        okhttp3.Call localVarCall = getFullRecordsUsingGETCall(channel, id, purchaserId, idType, maxCountVariants, _callback);
        return localVarCall;

    }

    /**
     * Get full records
     * 
     * @param channel channel (required)
     * @param id The record ids of the records which should be returned (required)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param idType Specifies which type of id is given. (optional, default to id)
     * @param maxCountVariants The maximum number of variants to return for every record (optional, default to 5)
     * @return FullRecordsResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public FullRecordsResult getFullRecordsUsingGET(String channel, List<String> id, String purchaserId, String idType, Integer maxCountVariants) throws ApiException {
        ApiResponse<FullRecordsResult> localVarResp = getFullRecordsUsingGETWithHttpInfo(channel, id, purchaserId, idType, maxCountVariants);
        return localVarResp.getData();
    }

    /**
     * Get full records
     * 
     * @param channel channel (required)
     * @param id The record ids of the records which should be returned (required)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param idType Specifies which type of id is given. (optional, default to id)
     * @param maxCountVariants The maximum number of variants to return for every record (optional, default to 5)
     * @return ApiResponse&lt;FullRecordsResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FullRecordsResult> getFullRecordsUsingGETWithHttpInfo(String channel, List<String> id, String purchaserId, String idType, Integer maxCountVariants) throws ApiException {
        okhttp3.Call localVarCall = getFullRecordsUsingGETValidateBeforeCall(channel, id, purchaserId, idType, maxCountVariants, null);
        Type localVarReturnType = new TypeToken<FullRecordsResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get full records (asynchronously)
     * 
     * @param channel channel (required)
     * @param id The record ids of the records which should be returned (required)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param idType Specifies which type of id is given. (optional, default to id)
     * @param maxCountVariants The maximum number of variants to return for every record (optional, default to 5)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getFullRecordsUsingGETAsync(String channel, List<String> id, String purchaserId, String idType, Integer maxCountVariants, final ApiCallback<FullRecordsResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFullRecordsUsingGETValidateBeforeCall(channel, id, purchaserId, idType, maxCountVariants, _callback);
        Type localVarReturnType = new TypeToken<FullRecordsResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getGeoUsingGET
     * @param channel channel (required)
     * @param id The product numbers of the records for which geo data should be returned. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGeoUsingGETCall(String channel, List<String> id, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v4/records/{channel}/geo"
            .replaceAll("\\{" + "channel" + "\\}", localVarApiClient.escapeString(channel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (id != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "id", id));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getGeoUsingGETValidateBeforeCall(String channel, List<String> id, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling getGeoUsingGET(Async)");
        }
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getGeoUsingGET(Async)");
        }
        

        okhttp3.Call localVarCall = getGeoUsingGETCall(channel, id, _callback);
        return localVarCall;

    }

    /**
     * Get geo data
     * 
     * @param channel channel (required)
     * @param id The product numbers of the records for which geo data should be returned. (required)
     * @return List&lt;Map&lt;String, Object&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public List<Map<String, Object>> getGeoUsingGET(String channel, List<String> id) throws ApiException {
        ApiResponse<List<Map<String, Object>>> localVarResp = getGeoUsingGETWithHttpInfo(channel, id);
        return localVarResp.getData();
    }

    /**
     * Get geo data
     * 
     * @param channel channel (required)
     * @param id The product numbers of the records for which geo data should be returned. (required)
     * @return ApiResponse&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Map<String, Object>>> getGeoUsingGETWithHttpInfo(String channel, List<String> id) throws ApiException {
        okhttp3.Call localVarCall = getGeoUsingGETValidateBeforeCall(channel, id, null);
        Type localVarReturnType = new TypeToken<List<Map<String, Object>>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get geo data (asynchronously)
     * 
     * @param channel channel (required)
     * @param id The product numbers of the records for which geo data should be returned. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getGeoUsingGETAsync(String channel, List<String> id, final ApiCallback<List<Map<String, Object>>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getGeoUsingGETValidateBeforeCall(channel, id, _callback);
        Type localVarReturnType = new TypeToken<List<Map<String, Object>>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getMarketsUsingGET
     * @param channel channel (required)
     * @param marketId The market ids. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMarketsUsingGETCall(String channel, List<String> marketId, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v4/markets/{channel}"
            .replaceAll("\\{" + "channel" + "\\}", localVarApiClient.escapeString(channel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (marketId != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "marketId", marketId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getMarketsUsingGETValidateBeforeCall(String channel, List<String> marketId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling getMarketsUsingGET(Async)");
        }
        

        okhttp3.Call localVarCall = getMarketsUsingGETCall(channel, marketId, _callback);
        return localVarCall;

    }

    /**
     * Get markets with location
     * 
     * @param channel channel (required)
     * @param marketId The market ids. (optional)
     * @return List&lt;Map&lt;String, Object&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public List<Map<String, Object>> getMarketsUsingGET(String channel, List<String> marketId) throws ApiException {
        ApiResponse<List<Map<String, Object>>> localVarResp = getMarketsUsingGETWithHttpInfo(channel, marketId);
        return localVarResp.getData();
    }

    /**
     * Get markets with location
     * 
     * @param channel channel (required)
     * @param marketId The market ids. (optional)
     * @return ApiResponse&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<Map<String, Object>>> getMarketsUsingGETWithHttpInfo(String channel, List<String> marketId) throws ApiException {
        okhttp3.Call localVarCall = getMarketsUsingGETValidateBeforeCall(channel, marketId, null);
        Type localVarReturnType = new TypeToken<List<Map<String, Object>>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get markets with location (asynchronously)
     * 
     * @param channel channel (required)
     * @param marketId The market ids. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getMarketsUsingGETAsync(String channel, List<String> marketId, final ApiCallback<List<Map<String, Object>>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getMarketsUsingGETValidateBeforeCall(channel, marketId, _callback);
        Type localVarReturnType = new TypeToken<List<Map<String, Object>>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRecommendationUsingGET
     * @param channel channel (required)
     * @param id Use this parameter to pass product ID(s) for which you wish to obtain recommendations. (required)
     * @param maxResults Use this parameter to specify the number of recommendations you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 0)
     * @param sid This parameter is used to pass an id for the user session. This is important for recognising the user, if you want to give him personalised recommendations, as well as for FACT-Finder tracking. (optional)
     * @param filter Filters for field values of recommended records. (optional)
     * @param idsOnly If the value true is passed, then only the record IDs will be returned, streamlining the results. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param usePersonalization Allows the activation/deactivation of the personalization of queries. true &#x3D; the search result will be personalized if the personalization module is activated and all other requirements are met; false &#x3D; the search result will not be personalized. (optional, default to true)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRecommendationUsingGETCall(String channel, List<String> id, Integer maxResults, String sid, List<String> filter, Boolean idsOnly, Boolean usePersonalization, String purchaserId, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v4/records/{channel}/recommendation"
            .replaceAll("\\{" + "channel" + "\\}", localVarApiClient.escapeString(channel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (id != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "id", id));
        }

        if (maxResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxResults", maxResults));
        }

        if (sid != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sid", sid));
        }

        if (filter != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "filter", filter));
        }

        if (idsOnly != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("idsOnly", idsOnly));
        }

        if (usePersonalization != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("usePersonalization", usePersonalization));
        }

        if (purchaserId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("purchaserId", purchaserId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRecommendationUsingGETValidateBeforeCall(String channel, List<String> id, Integer maxResults, String sid, List<String> filter, Boolean idsOnly, Boolean usePersonalization, String purchaserId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling getRecommendationUsingGET(Async)");
        }
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getRecommendationUsingGET(Async)");
        }
        

        okhttp3.Call localVarCall = getRecommendationUsingGETCall(channel, id, maxResults, sid, filter, idsOnly, usePersonalization, purchaserId, _callback);
        return localVarCall;

    }

    /**
     * Get recommendations
     * 
     * @param channel channel (required)
     * @param id Use this parameter to pass product ID(s) for which you wish to obtain recommendations. (required)
     * @param maxResults Use this parameter to specify the number of recommendations you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 0)
     * @param sid This parameter is used to pass an id for the user session. This is important for recognising the user, if you want to give him personalised recommendations, as well as for FACT-Finder tracking. (optional)
     * @param filter Filters for field values of recommended records. (optional)
     * @param idsOnly If the value true is passed, then only the record IDs will be returned, streamlining the results. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param usePersonalization Allows the activation/deactivation of the personalization of queries. true &#x3D; the search result will be personalized if the personalization module is activated and all other requirements are met; false &#x3D; the search result will not be personalized. (optional, default to true)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @return RecommendationResultWithFieldRoles
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public RecommendationResultWithFieldRoles getRecommendationUsingGET(String channel, List<String> id, Integer maxResults, String sid, List<String> filter, Boolean idsOnly, Boolean usePersonalization, String purchaserId) throws ApiException {
        ApiResponse<RecommendationResultWithFieldRoles> localVarResp = getRecommendationUsingGETWithHttpInfo(channel, id, maxResults, sid, filter, idsOnly, usePersonalization, purchaserId);
        return localVarResp.getData();
    }

    /**
     * Get recommendations
     * 
     * @param channel channel (required)
     * @param id Use this parameter to pass product ID(s) for which you wish to obtain recommendations. (required)
     * @param maxResults Use this parameter to specify the number of recommendations you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 0)
     * @param sid This parameter is used to pass an id for the user session. This is important for recognising the user, if you want to give him personalised recommendations, as well as for FACT-Finder tracking. (optional)
     * @param filter Filters for field values of recommended records. (optional)
     * @param idsOnly If the value true is passed, then only the record IDs will be returned, streamlining the results. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param usePersonalization Allows the activation/deactivation of the personalization of queries. true &#x3D; the search result will be personalized if the personalization module is activated and all other requirements are met; false &#x3D; the search result will not be personalized. (optional, default to true)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @return ApiResponse&lt;RecommendationResultWithFieldRoles&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RecommendationResultWithFieldRoles> getRecommendationUsingGETWithHttpInfo(String channel, List<String> id, Integer maxResults, String sid, List<String> filter, Boolean idsOnly, Boolean usePersonalization, String purchaserId) throws ApiException {
        okhttp3.Call localVarCall = getRecommendationUsingGETValidateBeforeCall(channel, id, maxResults, sid, filter, idsOnly, usePersonalization, purchaserId, null);
        Type localVarReturnType = new TypeToken<RecommendationResultWithFieldRoles>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get recommendations (asynchronously)
     * 
     * @param channel channel (required)
     * @param id Use this parameter to pass product ID(s) for which you wish to obtain recommendations. (required)
     * @param maxResults Use this parameter to specify the number of recommendations you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 0)
     * @param sid This parameter is used to pass an id for the user session. This is important for recognising the user, if you want to give him personalised recommendations, as well as for FACT-Finder tracking. (optional)
     * @param filter Filters for field values of recommended records. (optional)
     * @param idsOnly If the value true is passed, then only the record IDs will be returned, streamlining the results. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param usePersonalization Allows the activation/deactivation of the personalization of queries. true &#x3D; the search result will be personalized if the personalization module is activated and all other requirements are met; false &#x3D; the search result will not be personalized. (optional, default to true)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRecommendationUsingGETAsync(String channel, List<String> id, Integer maxResults, String sid, List<String> filter, Boolean idsOnly, Boolean usePersonalization, String purchaserId, final ApiCallback<RecommendationResultWithFieldRoles> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRecommendationUsingGETValidateBeforeCall(channel, id, maxResults, sid, filter, idsOnly, usePersonalization, purchaserId, _callback);
        Type localVarReturnType = new TypeToken<RecommendationResultWithFieldRoles>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRecordMetaGetUsingGET
     * @param channel channel (required)
     * @param id The record ids of the records which should be returned (required)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param idType Specifies which type of id is given. (optional, default to id)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRecordMetaGetUsingGETCall(String channel, List<String> id, String purchaserId, String idType, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v4/records/{channel}/meta"
            .replaceAll("\\{" + "channel" + "\\}", localVarApiClient.escapeString(channel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (purchaserId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("purchaserId", purchaserId));
        }

        if (id != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "id", id));
        }

        if (idType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("idType", idType));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRecordMetaGetUsingGETValidateBeforeCall(String channel, List<String> id, String purchaserId, String idType, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling getRecordMetaGetUsingGET(Async)");
        }
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getRecordMetaGetUsingGET(Async)");
        }
        

        okhttp3.Call localVarCall = getRecordMetaGetUsingGETCall(channel, id, purchaserId, idType, _callback);
        return localVarCall;

    }

    /**
     * Retrieve record metadata
     * 
     * @param channel channel (required)
     * @param id The record ids of the records which should be returned (required)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param idType Specifies which type of id is given. (optional, default to id)
     * @return RecordMetaResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public RecordMetaResult getRecordMetaGetUsingGET(String channel, List<String> id, String purchaserId, String idType) throws ApiException {
        ApiResponse<RecordMetaResult> localVarResp = getRecordMetaGetUsingGETWithHttpInfo(channel, id, purchaserId, idType);
        return localVarResp.getData();
    }

    /**
     * Retrieve record metadata
     * 
     * @param channel channel (required)
     * @param id The record ids of the records which should be returned (required)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param idType Specifies which type of id is given. (optional, default to id)
     * @return ApiResponse&lt;RecordMetaResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RecordMetaResult> getRecordMetaGetUsingGETWithHttpInfo(String channel, List<String> id, String purchaserId, String idType) throws ApiException {
        okhttp3.Call localVarCall = getRecordMetaGetUsingGETValidateBeforeCall(channel, id, purchaserId, idType, null);
        Type localVarReturnType = new TypeToken<RecordMetaResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve record metadata (asynchronously)
     * 
     * @param channel channel (required)
     * @param id The record ids of the records which should be returned (required)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param idType Specifies which type of id is given. (optional, default to id)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRecordMetaGetUsingGETAsync(String channel, List<String> id, String purchaserId, String idType, final ApiCallback<RecordMetaResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRecordMetaGetUsingGETValidateBeforeCall(channel, id, purchaserId, idType, _callback);
        Type localVarReturnType = new TypeToken<RecordMetaResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRecordMetaPostUsingPOST
     * @param channel channel (required)
     * @param metaRequest metaRequest (required)
     * @param idType Specifies which type of id is given. (optional, default to id)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRecordMetaPostUsingPOSTCall(String channel, MetaRequest metaRequest, String idType, String purchaserId, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = metaRequest;

        // create path and map variables
        String localVarPath = "/rest/v4/records/{channel}/meta"
            .replaceAll("\\{" + "channel" + "\\}", localVarApiClient.escapeString(channel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (idType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("idType", idType));
        }

        if (purchaserId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("purchaserId", purchaserId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRecordMetaPostUsingPOSTValidateBeforeCall(String channel, MetaRequest metaRequest, String idType, String purchaserId, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling getRecordMetaPostUsingPOST(Async)");
        }
        
        // verify the required parameter 'metaRequest' is set
        if (metaRequest == null) {
            throw new ApiException("Missing the required parameter 'metaRequest' when calling getRecordMetaPostUsingPOST(Async)");
        }
        

        okhttp3.Call localVarCall = getRecordMetaPostUsingPOSTCall(channel, metaRequest, idType, purchaserId, _callback);
        return localVarCall;

    }

    /**
     * Retrieve record metadata
     * 
     * @param channel channel (required)
     * @param metaRequest metaRequest (required)
     * @param idType Specifies which type of id is given. (optional, default to id)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @return RecordMetaResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public RecordMetaResult getRecordMetaPostUsingPOST(String channel, MetaRequest metaRequest, String idType, String purchaserId) throws ApiException {
        ApiResponse<RecordMetaResult> localVarResp = getRecordMetaPostUsingPOSTWithHttpInfo(channel, metaRequest, idType, purchaserId);
        return localVarResp.getData();
    }

    /**
     * Retrieve record metadata
     * 
     * @param channel channel (required)
     * @param metaRequest metaRequest (required)
     * @param idType Specifies which type of id is given. (optional, default to id)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @return ApiResponse&lt;RecordMetaResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RecordMetaResult> getRecordMetaPostUsingPOSTWithHttpInfo(String channel, MetaRequest metaRequest, String idType, String purchaserId) throws ApiException {
        okhttp3.Call localVarCall = getRecordMetaPostUsingPOSTValidateBeforeCall(channel, metaRequest, idType, purchaserId, null);
        Type localVarReturnType = new TypeToken<RecordMetaResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve record metadata (asynchronously)
     * 
     * @param channel channel (required)
     * @param metaRequest metaRequest (required)
     * @param idType Specifies which type of id is given. (optional, default to id)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRecordMetaPostUsingPOSTAsync(String channel, MetaRequest metaRequest, String idType, String purchaserId, final ApiCallback<RecordMetaResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRecordMetaPostUsingPOSTValidateBeforeCall(channel, metaRequest, idType, purchaserId, _callback);
        Type localVarReturnType = new TypeToken<RecordMetaResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getRecordsUsingGET
     * @param channel channel (required)
     * @param productNumber The product numbers of the records which should be returned. (required)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param verbose verbose (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRecordsUsingGETCall(String channel, List<String> productNumber, String purchaserId, Boolean verbose, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v4/records/{channel}"
            .replaceAll("\\{" + "channel" + "\\}", localVarApiClient.escapeString(channel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (productNumber != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "productNumber", productNumber));
        }

        if (purchaserId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("purchaserId", purchaserId));
        }

        if (verbose != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("verbose", verbose));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRecordsUsingGETValidateBeforeCall(String channel, List<String> productNumber, String purchaserId, Boolean verbose, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling getRecordsUsingGET(Async)");
        }
        
        // verify the required parameter 'productNumber' is set
        if (productNumber == null) {
            throw new ApiException("Missing the required parameter 'productNumber' when calling getRecordsUsingGET(Async)");
        }
        

        okhttp3.Call localVarCall = getRecordsUsingGETCall(channel, productNumber, purchaserId, verbose, _callback);
        return localVarCall;

    }

    /**
     * Get records
     * 
     * @param channel channel (required)
     * @param productNumber The product numbers of the records which should be returned. (required)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param verbose verbose (optional, default to false)
     * @return FlatRecordsResult
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public FlatRecordsResult getRecordsUsingGET(String channel, List<String> productNumber, String purchaserId, Boolean verbose) throws ApiException {
        ApiResponse<FlatRecordsResult> localVarResp = getRecordsUsingGETWithHttpInfo(channel, productNumber, purchaserId, verbose);
        return localVarResp.getData();
    }

    /**
     * Get records
     * 
     * @param channel channel (required)
     * @param productNumber The product numbers of the records which should be returned. (required)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param verbose verbose (optional, default to false)
     * @return ApiResponse&lt;FlatRecordsResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<FlatRecordsResult> getRecordsUsingGETWithHttpInfo(String channel, List<String> productNumber, String purchaserId, Boolean verbose) throws ApiException {
        okhttp3.Call localVarCall = getRecordsUsingGETValidateBeforeCall(channel, productNumber, purchaserId, verbose, null);
        Type localVarReturnType = new TypeToken<FlatRecordsResult>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get records (asynchronously)
     * 
     * @param channel channel (required)
     * @param productNumber The product numbers of the records which should be returned. (required)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param verbose verbose (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getRecordsUsingGETAsync(String channel, List<String> productNumber, String purchaserId, Boolean verbose, final ApiCallback<FlatRecordsResult> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRecordsUsingGETValidateBeforeCall(channel, productNumber, purchaserId, verbose, _callback);
        Type localVarReturnType = new TypeToken<FlatRecordsResult>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getSimilarProductsUsingGET
     * @param channel channel (required)
     * @param id Use this parameter to pass the product ID for which you wish to obtain similar products. (required)
     * @param idType Use this parameter to determine the type of id passed to the method. (required)
     * @param filter Filters for field values of recommended records. (optional)
     * @param idsOnly If the value true is passed, then only the record IDs will be returned, streamlining the results. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param maxResults Use this parameter to specify the number of similar articles you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 10)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSimilarProductsUsingGETCall(String channel, String id, String idType, List<String> filter, Boolean idsOnly, String purchaserId, Integer maxResults, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v4/records/{channel}/similar"
            .replaceAll("\\{" + "channel" + "\\}", localVarApiClient.escapeString(channel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (id != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("id", id));
        }

        if (idType != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("idType", idType));
        }

        if (filter != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "filter", filter));
        }

        if (idsOnly != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("idsOnly", idsOnly));
        }

        if (purchaserId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("purchaserId", purchaserId));
        }

        if (maxResults != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxResults", maxResults));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSimilarProductsUsingGETValidateBeforeCall(String channel, String id, String idType, List<String> filter, Boolean idsOnly, String purchaserId, Integer maxResults, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling getSimilarProductsUsingGET(Async)");
        }
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getSimilarProductsUsingGET(Async)");
        }
        
        // verify the required parameter 'idType' is set
        if (idType == null) {
            throw new ApiException("Missing the required parameter 'idType' when calling getSimilarProductsUsingGET(Async)");
        }
        

        okhttp3.Call localVarCall = getSimilarProductsUsingGETCall(channel, id, idType, filter, idsOnly, purchaserId, maxResults, _callback);
        return localVarCall;

    }

    /**
     * Get similar products
     * 
     * @param channel channel (required)
     * @param id Use this parameter to pass the product ID for which you wish to obtain similar products. (required)
     * @param idType Use this parameter to determine the type of id passed to the method. (required)
     * @param filter Filters for field values of recommended records. (optional)
     * @param idsOnly If the value true is passed, then only the record IDs will be returned, streamlining the results. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param maxResults Use this parameter to specify the number of similar articles you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 10)
     * @return SimilarProductsWithFieldRoles
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public SimilarProductsWithFieldRoles getSimilarProductsUsingGET(String channel, String id, String idType, List<String> filter, Boolean idsOnly, String purchaserId, Integer maxResults) throws ApiException {
        ApiResponse<SimilarProductsWithFieldRoles> localVarResp = getSimilarProductsUsingGETWithHttpInfo(channel, id, idType, filter, idsOnly, purchaserId, maxResults);
        return localVarResp.getData();
    }

    /**
     * Get similar products
     * 
     * @param channel channel (required)
     * @param id Use this parameter to pass the product ID for which you wish to obtain similar products. (required)
     * @param idType Use this parameter to determine the type of id passed to the method. (required)
     * @param filter Filters for field values of recommended records. (optional)
     * @param idsOnly If the value true is passed, then only the record IDs will be returned, streamlining the results. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param maxResults Use this parameter to specify the number of similar articles you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 10)
     * @return ApiResponse&lt;SimilarProductsWithFieldRoles&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SimilarProductsWithFieldRoles> getSimilarProductsUsingGETWithHttpInfo(String channel, String id, String idType, List<String> filter, Boolean idsOnly, String purchaserId, Integer maxResults) throws ApiException {
        okhttp3.Call localVarCall = getSimilarProductsUsingGETValidateBeforeCall(channel, id, idType, filter, idsOnly, purchaserId, maxResults, null);
        Type localVarReturnType = new TypeToken<SimilarProductsWithFieldRoles>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get similar products (asynchronously)
     * 
     * @param channel channel (required)
     * @param id Use this parameter to pass the product ID for which you wish to obtain similar products. (required)
     * @param idType Use this parameter to determine the type of id passed to the method. (required)
     * @param filter Filters for field values of recommended records. (optional)
     * @param idsOnly If the value true is passed, then only the record IDs will be returned, streamlining the results. If you do not need the other information in the results, this will help you to improve performance. (optional, default to false)
     * @param purchaserId Use this parameter to pass the purchaser ID. This ID is only needed, if the &#39;customer specific pricing&#39; module is active. Otherwise it will be ignored. (optional)
     * @param maxResults Use this parameter to specify the number of similar articles you would like. The default value from the configuration is used if the parameter is not specified. (optional, default to 10)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getSimilarProductsUsingGETAsync(String channel, String id, String idType, List<String> filter, Boolean idsOnly, String purchaserId, Integer maxResults, final ApiCallback<SimilarProductsWithFieldRoles> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSimilarProductsUsingGETValidateBeforeCall(channel, id, idType, filter, idsOnly, purchaserId, maxResults, _callback);
        Type localVarReturnType = new TypeToken<SimilarProductsWithFieldRoles>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for insertRecordsUsingPOST
     * @param channel channel (required)
     * @param records The records which should be inserted (required)
     * @param verbose verbose (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call insertRecordsUsingPOSTCall(String channel, List<Map<String, Object>> records, Boolean verbose, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = records;

        // create path and map variables
        String localVarPath = "/rest/v4/records/{channel}"
            .replaceAll("\\{" + "channel" + "\\}", localVarApiClient.escapeString(channel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (verbose != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("verbose", verbose));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call insertRecordsUsingPOSTValidateBeforeCall(String channel, List<Map<String, Object>> records, Boolean verbose, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling insertRecordsUsingPOST(Async)");
        }
        
        // verify the required parameter 'records' is set
        if (records == null) {
            throw new ApiException("Missing the required parameter 'records' when calling insertRecordsUsingPOST(Async)");
        }
        

        okhttp3.Call localVarCall = insertRecordsUsingPOSTCall(channel, records, verbose, _callback);
        return localVarCall;

    }

    /**
     * Insert records
     * 
     * @param channel channel (required)
     * @param records The records which should be inserted (required)
     * @param verbose verbose (optional, default to false)
     * @return List&lt;DeltaUpdateResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public List<DeltaUpdateResult> insertRecordsUsingPOST(String channel, List<Map<String, Object>> records, Boolean verbose) throws ApiException {
        ApiResponse<List<DeltaUpdateResult>> localVarResp = insertRecordsUsingPOSTWithHttpInfo(channel, records, verbose);
        return localVarResp.getData();
    }

    /**
     * Insert records
     * 
     * @param channel channel (required)
     * @param records The records which should be inserted (required)
     * @param verbose verbose (optional, default to false)
     * @return ApiResponse&lt;List&lt;DeltaUpdateResult&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<DeltaUpdateResult>> insertRecordsUsingPOSTWithHttpInfo(String channel, List<Map<String, Object>> records, Boolean verbose) throws ApiException {
        okhttp3.Call localVarCall = insertRecordsUsingPOSTValidateBeforeCall(channel, records, verbose, null);
        Type localVarReturnType = new TypeToken<List<DeltaUpdateResult>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Insert records (asynchronously)
     * 
     * @param channel channel (required)
     * @param records The records which should be inserted (required)
     * @param verbose verbose (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call insertRecordsUsingPOSTAsync(String channel, List<Map<String, Object>> records, Boolean verbose, final ApiCallback<List<DeltaUpdateResult>> _callback) throws ApiException {

        okhttp3.Call localVarCall = insertRecordsUsingPOSTValidateBeforeCall(channel, records, verbose, _callback);
        Type localVarReturnType = new TypeToken<List<DeltaUpdateResult>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateCustomerPricesUsingPOST
     * @param channel channel (required)
     * @param records The records which should be inserted (required)
     * @param verbose verbose (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateCustomerPricesUsingPOSTCall(String channel, List<Map<String, Object>> records, Boolean verbose, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = records;

        // create path and map variables
        String localVarPath = "/rest/v4/records/{channel}/customerprices"
            .replaceAll("\\{" + "channel" + "\\}", localVarApiClient.escapeString(channel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (verbose != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("verbose", verbose));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateCustomerPricesUsingPOSTValidateBeforeCall(String channel, List<Map<String, Object>> records, Boolean verbose, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling updateCustomerPricesUsingPOST(Async)");
        }
        
        // verify the required parameter 'records' is set
        if (records == null) {
            throw new ApiException("Missing the required parameter 'records' when calling updateCustomerPricesUsingPOST(Async)");
        }
        

        okhttp3.Call localVarCall = updateCustomerPricesUsingPOSTCall(channel, records, verbose, _callback);
        return localVarCall;

    }

    /**
     * Update customer prices
     * 
     * @param channel channel (required)
     * @param records The records which should be inserted (required)
     * @param verbose verbose (optional, default to false)
     * @return List&lt;CustomerPriceUpdateResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public List<CustomerPriceUpdateResult> updateCustomerPricesUsingPOST(String channel, List<Map<String, Object>> records, Boolean verbose) throws ApiException {
        ApiResponse<List<CustomerPriceUpdateResult>> localVarResp = updateCustomerPricesUsingPOSTWithHttpInfo(channel, records, verbose);
        return localVarResp.getData();
    }

    /**
     * Update customer prices
     * 
     * @param channel channel (required)
     * @param records The records which should be inserted (required)
     * @param verbose verbose (optional, default to false)
     * @return ApiResponse&lt;List&lt;CustomerPriceUpdateResult&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<CustomerPriceUpdateResult>> updateCustomerPricesUsingPOSTWithHttpInfo(String channel, List<Map<String, Object>> records, Boolean verbose) throws ApiException {
        okhttp3.Call localVarCall = updateCustomerPricesUsingPOSTValidateBeforeCall(channel, records, verbose, null);
        Type localVarReturnType = new TypeToken<List<CustomerPriceUpdateResult>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update customer prices (asynchronously)
     * 
     * @param channel channel (required)
     * @param records The records which should be inserted (required)
     * @param verbose verbose (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateCustomerPricesUsingPOSTAsync(String channel, List<Map<String, Object>> records, Boolean verbose, final ApiCallback<List<CustomerPriceUpdateResult>> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateCustomerPricesUsingPOSTValidateBeforeCall(channel, records, verbose, _callback);
        Type localVarReturnType = new TypeToken<List<CustomerPriceUpdateResult>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateGeoUsingPOST
     * @param channel channel (required)
     * @param records The records which should be updated (required)
     * @param verbose verbose (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateGeoUsingPOSTCall(String channel, List<Map<String, Object>> records, Boolean verbose, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = records;

        // create path and map variables
        String localVarPath = "/rest/v4/records/{channel}/geo"
            .replaceAll("\\{" + "channel" + "\\}", localVarApiClient.escapeString(channel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (verbose != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("verbose", verbose));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateGeoUsingPOSTValidateBeforeCall(String channel, List<Map<String, Object>> records, Boolean verbose, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling updateGeoUsingPOST(Async)");
        }
        
        // verify the required parameter 'records' is set
        if (records == null) {
            throw new ApiException("Missing the required parameter 'records' when calling updateGeoUsingPOST(Async)");
        }
        

        okhttp3.Call localVarCall = updateGeoUsingPOSTCall(channel, records, verbose, _callback);
        return localVarCall;

    }

    /**
     * Update geo data
     * 
     * @param channel channel (required)
     * @param records The records which should be updated (required)
     * @param verbose verbose (optional, default to false)
     * @return List&lt;GeoUpdateResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public List<GeoUpdateResult> updateGeoUsingPOST(String channel, List<Map<String, Object>> records, Boolean verbose) throws ApiException {
        ApiResponse<List<GeoUpdateResult>> localVarResp = updateGeoUsingPOSTWithHttpInfo(channel, records, verbose);
        return localVarResp.getData();
    }

    /**
     * Update geo data
     * 
     * @param channel channel (required)
     * @param records The records which should be updated (required)
     * @param verbose verbose (optional, default to false)
     * @return ApiResponse&lt;List&lt;GeoUpdateResult&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<GeoUpdateResult>> updateGeoUsingPOSTWithHttpInfo(String channel, List<Map<String, Object>> records, Boolean verbose) throws ApiException {
        okhttp3.Call localVarCall = updateGeoUsingPOSTValidateBeforeCall(channel, records, verbose, null);
        Type localVarReturnType = new TypeToken<List<GeoUpdateResult>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update geo data (asynchronously)
     * 
     * @param channel channel (required)
     * @param records The records which should be updated (required)
     * @param verbose verbose (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateGeoUsingPOSTAsync(String channel, List<Map<String, Object>> records, Boolean verbose, final ApiCallback<List<GeoUpdateResult>> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateGeoUsingPOSTValidateBeforeCall(channel, records, verbose, _callback);
        Type localVarReturnType = new TypeToken<List<GeoUpdateResult>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateMarketsUsingPOST
     * @param channel channel (required)
     * @param markets The markets which should be updated (required)
     * @param verbose verbose (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateMarketsUsingPOSTCall(String channel, List<Map<String, Object>> markets, Boolean verbose, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = markets;

        // create path and map variables
        String localVarPath = "/rest/v4/markets/{channel}"
            .replaceAll("\\{" + "channel" + "\\}", localVarApiClient.escapeString(channel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (verbose != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("verbose", verbose));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateMarketsUsingPOSTValidateBeforeCall(String channel, List<Map<String, Object>> markets, Boolean verbose, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling updateMarketsUsingPOST(Async)");
        }
        
        // verify the required parameter 'markets' is set
        if (markets == null) {
            throw new ApiException("Missing the required parameter 'markets' when calling updateMarketsUsingPOST(Async)");
        }
        

        okhttp3.Call localVarCall = updateMarketsUsingPOSTCall(channel, markets, verbose, _callback);
        return localVarCall;

    }

    /**
     * Update markets
     * 
     * @param channel channel (required)
     * @param markets The markets which should be updated (required)
     * @param verbose verbose (optional, default to false)
     * @return List&lt;MarketUpdateResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public List<MarketUpdateResult> updateMarketsUsingPOST(String channel, List<Map<String, Object>> markets, Boolean verbose) throws ApiException {
        ApiResponse<List<MarketUpdateResult>> localVarResp = updateMarketsUsingPOSTWithHttpInfo(channel, markets, verbose);
        return localVarResp.getData();
    }

    /**
     * Update markets
     * 
     * @param channel channel (required)
     * @param markets The markets which should be updated (required)
     * @param verbose verbose (optional, default to false)
     * @return ApiResponse&lt;List&lt;MarketUpdateResult&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<MarketUpdateResult>> updateMarketsUsingPOSTWithHttpInfo(String channel, List<Map<String, Object>> markets, Boolean verbose) throws ApiException {
        okhttp3.Call localVarCall = updateMarketsUsingPOSTValidateBeforeCall(channel, markets, verbose, null);
        Type localVarReturnType = new TypeToken<List<MarketUpdateResult>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update markets (asynchronously)
     * 
     * @param channel channel (required)
     * @param markets The markets which should be updated (required)
     * @param verbose verbose (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateMarketsUsingPOSTAsync(String channel, List<Map<String, Object>> markets, Boolean verbose, final ApiCallback<List<MarketUpdateResult>> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateMarketsUsingPOSTValidateBeforeCall(channel, markets, verbose, _callback);
        Type localVarReturnType = new TypeToken<List<MarketUpdateResult>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateUsingPUT
     * @param channel channel (required)
     * @param records The records which should be updated (required)
     * @param verbose verbose (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateUsingPUTCall(String channel, List<Map<String, Object>> records, Boolean verbose, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = records;

        // create path and map variables
        String localVarPath = "/rest/v4/records/{channel}"
            .replaceAll("\\{" + "channel" + "\\}", localVarApiClient.escapeString(channel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (verbose != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("verbose", verbose));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateUsingPUTValidateBeforeCall(String channel, List<Map<String, Object>> records, Boolean verbose, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling updateUsingPUT(Async)");
        }
        
        // verify the required parameter 'records' is set
        if (records == null) {
            throw new ApiException("Missing the required parameter 'records' when calling updateUsingPUT(Async)");
        }
        

        okhttp3.Call localVarCall = updateUsingPUTCall(channel, records, verbose, _callback);
        return localVarCall;

    }

    /**
     * Update records
     * 
     * @param channel channel (required)
     * @param records The records which should be updated (required)
     * @param verbose verbose (optional, default to false)
     * @return List&lt;DeltaUpdateResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public List<DeltaUpdateResult> updateUsingPUT(String channel, List<Map<String, Object>> records, Boolean verbose) throws ApiException {
        ApiResponse<List<DeltaUpdateResult>> localVarResp = updateUsingPUTWithHttpInfo(channel, records, verbose);
        return localVarResp.getData();
    }

    /**
     * Update records
     * 
     * @param channel channel (required)
     * @param records The records which should be updated (required)
     * @param verbose verbose (optional, default to false)
     * @return ApiResponse&lt;List&lt;DeltaUpdateResult&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<DeltaUpdateResult>> updateUsingPUTWithHttpInfo(String channel, List<Map<String, Object>> records, Boolean verbose) throws ApiException {
        okhttp3.Call localVarCall = updateUsingPUTValidateBeforeCall(channel, records, verbose, null);
        Type localVarReturnType = new TypeToken<List<DeltaUpdateResult>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update records (asynchronously)
     * 
     * @param channel channel (required)
     * @param records The records which should be updated (required)
     * @param verbose verbose (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateUsingPUTAsync(String channel, List<Map<String, Object>> records, Boolean verbose, final ApiCallback<List<DeltaUpdateResult>> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateUsingPUTValidateBeforeCall(channel, records, verbose, _callback);
        Type localVarReturnType = new TypeToken<List<DeltaUpdateResult>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for upsertRecordsUsingPUT
     * @param channel channel (required)
     * @param records The records which should be upserted (required)
     * @param verbose verbose (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call upsertRecordsUsingPUTCall(String channel, List<Map<String, Object>> records, Boolean verbose, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = records;

        // create path and map variables
        String localVarPath = "/rest/v4/records/{channel}/upsert"
            .replaceAll("\\{" + "channel" + "\\}", localVarApiClient.escapeString(channel.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (verbose != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("verbose", verbose));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call upsertRecordsUsingPUTValidateBeforeCall(String channel, List<Map<String, Object>> records, Boolean verbose, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling upsertRecordsUsingPUT(Async)");
        }
        
        // verify the required parameter 'records' is set
        if (records == null) {
            throw new ApiException("Missing the required parameter 'records' when calling upsertRecordsUsingPUT(Async)");
        }
        

        okhttp3.Call localVarCall = upsertRecordsUsingPUTCall(channel, records, verbose, _callback);
        return localVarCall;

    }

    /**
     * Upsert records
     * Update or insert records; Without variants: inserts records when they do not already exist, or replaces them if they do. With Variants: inserts a master document when it does not exists; inserts a variant and replaces the master values if the variant does not exist; replaces a variant and replaces the master values if the variant does already exist.
     * @param channel channel (required)
     * @param records The records which should be upserted (required)
     * @param verbose verbose (optional, default to false)
     * @return List&lt;DeltaUpdateResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public List<DeltaUpdateResult> upsertRecordsUsingPUT(String channel, List<Map<String, Object>> records, Boolean verbose) throws ApiException {
        ApiResponse<List<DeltaUpdateResult>> localVarResp = upsertRecordsUsingPUTWithHttpInfo(channel, records, verbose);
        return localVarResp.getData();
    }

    /**
     * Upsert records
     * Update or insert records; Without variants: inserts records when they do not already exist, or replaces them if they do. With Variants: inserts a master document when it does not exists; inserts a variant and replaces the master values if the variant does not exist; replaces a variant and replaces the master values if the variant does already exist.
     * @param channel channel (required)
     * @param records The records which should be upserted (required)
     * @param verbose verbose (optional, default to false)
     * @return ApiResponse&lt;List&lt;DeltaUpdateResult&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<DeltaUpdateResult>> upsertRecordsUsingPUTWithHttpInfo(String channel, List<Map<String, Object>> records, Boolean verbose) throws ApiException {
        okhttp3.Call localVarCall = upsertRecordsUsingPUTValidateBeforeCall(channel, records, verbose, null);
        Type localVarReturnType = new TypeToken<List<DeltaUpdateResult>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Upsert records (asynchronously)
     * Update or insert records; Without variants: inserts records when they do not already exist, or replaces them if they do. With Variants: inserts a master document when it does not exists; inserts a variant and replaces the master values if the variant does not exist; replaces a variant and replaces the master values if the variant does already exist.
     * @param channel channel (required)
     * @param records The records which should be upserted (required)
     * @param verbose verbose (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call upsertRecordsUsingPUTAsync(String channel, List<Map<String, Object>> records, Boolean verbose, final ApiCallback<List<DeltaUpdateResult>> _callback) throws ApiException {

        okhttp3.Call localVarCall = upsertRecordsUsingPUTValidateBeforeCall(channel, records, verbose, _callback);
        Type localVarReturnType = new TypeToken<List<DeltaUpdateResult>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
