/*
 * FACT-Finder REST-API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package de.factfinder.client.api;

import de.factfinder.client.ApiCallback;
import de.factfinder.client.ApiClient;
import de.factfinder.client.ApiException;
import de.factfinder.client.ApiResponse;
import de.factfinder.client.Configuration;
import de.factfinder.client.Pair;
import de.factfinder.client.ProgressRequestBody;
import de.factfinder.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import de.factfinder.client.model.ApiError;
import de.factfinder.client.model.ImportChannelResult;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ImportApi {
    private ApiClient localVarApiClient;

    public ImportApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ImportApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    /**
     * Build call for isImportRunningUsingGET
     * @param channel channel (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call isImportRunningUsingGETCall(List<String> channel, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v4/import/running";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "channel", channel));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call isImportRunningUsingGETValidateBeforeCall(List<String> channel, final ApiCallback _callback) throws ApiException {
        
        // verify the required parameter 'channel' is set
        if (channel == null) {
            throw new ApiException("Missing the required parameter 'channel' when calling isImportRunningUsingGET(Async)");
        }
        

        okhttp3.Call localVarCall = isImportRunningUsingGETCall(channel, _callback);
        return localVarCall;

    }

    /**
     * Check if an import is running in any of the supplied channels
     * 
     * @param channel channel (required)
     * @return Boolean
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public Boolean isImportRunningUsingGET(List<String> channel) throws ApiException {
        ApiResponse<Boolean> localVarResp = isImportRunningUsingGETWithHttpInfo(channel);
        return localVarResp.getData();
    }

    /**
     * Check if an import is running in any of the supplied channels
     * 
     * @param channel channel (required)
     * @return ApiResponse&lt;Boolean&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Boolean> isImportRunningUsingGETWithHttpInfo(List<String> channel) throws ApiException {
        okhttp3.Call localVarCall = isImportRunningUsingGETValidateBeforeCall(channel, null);
        Type localVarReturnType = new TypeToken<Boolean>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Check if an import is running in any of the supplied channels (asynchronously)
     * 
     * @param channel channel (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call isImportRunningUsingGETAsync(List<String> channel, final ApiCallback<Boolean> _callback) throws ApiException {

        okhttp3.Call localVarCall = isImportRunningUsingGETValidateBeforeCall(channel, _callback);
        Type localVarReturnType = new TypeToken<Boolean>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for refreshRecommendationDatabasesUsingPOST
     * @param channel channel (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call refreshRecommendationDatabasesUsingPOSTCall(List<String> channel, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v4/import/refreshRecommendations";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "channel", channel));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call refreshRecommendationDatabasesUsingPOSTValidateBeforeCall(List<String> channel, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = refreshRecommendationDatabasesUsingPOSTCall(channel, _callback);
        return localVarCall;

    }

    /**
     * Refresh recommendation databases
     * 
     * @param channel channel (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public void refreshRecommendationDatabasesUsingPOST(List<String> channel) throws ApiException {
        refreshRecommendationDatabasesUsingPOSTWithHttpInfo(channel);
    }

    /**
     * Refresh recommendation databases
     * 
     * @param channel channel (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> refreshRecommendationDatabasesUsingPOSTWithHttpInfo(List<String> channel) throws ApiException {
        okhttp3.Call localVarCall = refreshRecommendationDatabasesUsingPOSTValidateBeforeCall(channel, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Refresh recommendation databases (asynchronously)
     * 
     * @param channel channel (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call refreshRecommendationDatabasesUsingPOSTAsync(List<String> channel, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = refreshRecommendationDatabasesUsingPOSTValidateBeforeCall(channel, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for startCustomerSpecificPricingImportUsingPOST
     * @param channel channel (optional)
     * @param download if true: causes the import file to be updated first. If no URL is stored in the FACT-Finder configuration, this parameter has no effect. (optional, default to false)
     * @param cacheFlush if true: causes a cache flush after a channel has been imported (optional, default to false)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @param importStage IMPORT_ONLY only fills the intermediate DB, LOAD_ONLY imports that database into memory, and FULL combines both stages (optional, default to FULL)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call startCustomerSpecificPricingImportUsingPOSTCall(List<String> channel, Boolean download, Boolean cacheFlush, Boolean quiet, String importStage, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v4/import/customerprices";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "channel", channel));
        }

        if (download != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("download", download));
        }

        if (cacheFlush != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cacheFlush", cacheFlush));
        }

        if (quiet != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("quiet", quiet));
        }

        if (importStage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("importStage", importStage));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call startCustomerSpecificPricingImportUsingPOSTValidateBeforeCall(List<String> channel, Boolean download, Boolean cacheFlush, Boolean quiet, String importStage, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = startCustomerSpecificPricingImportUsingPOSTCall(channel, download, cacheFlush, quiet, importStage, _callback);
        return localVarCall;

    }

    /**
     * Start customer specific pricing import
     * 
     * @param channel channel (optional)
     * @param download if true: causes the import file to be updated first. If no URL is stored in the FACT-Finder configuration, this parameter has no effect. (optional, default to false)
     * @param cacheFlush if true: causes a cache flush after a channel has been imported (optional, default to false)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @param importStage IMPORT_ONLY only fills the intermediate DB, LOAD_ONLY imports that database into memory, and FULL combines both stages (optional, default to FULL)
     * @return List&lt;ImportChannelResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public List<ImportChannelResult> startCustomerSpecificPricingImportUsingPOST(List<String> channel, Boolean download, Boolean cacheFlush, Boolean quiet, String importStage) throws ApiException {
        ApiResponse<List<ImportChannelResult>> localVarResp = startCustomerSpecificPricingImportUsingPOSTWithHttpInfo(channel, download, cacheFlush, quiet, importStage);
        return localVarResp.getData();
    }

    /**
     * Start customer specific pricing import
     * 
     * @param channel channel (optional)
     * @param download if true: causes the import file to be updated first. If no URL is stored in the FACT-Finder configuration, this parameter has no effect. (optional, default to false)
     * @param cacheFlush if true: causes a cache flush after a channel has been imported (optional, default to false)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @param importStage IMPORT_ONLY only fills the intermediate DB, LOAD_ONLY imports that database into memory, and FULL combines both stages (optional, default to FULL)
     * @return ApiResponse&lt;List&lt;ImportChannelResult&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ImportChannelResult>> startCustomerSpecificPricingImportUsingPOSTWithHttpInfo(List<String> channel, Boolean download, Boolean cacheFlush, Boolean quiet, String importStage) throws ApiException {
        okhttp3.Call localVarCall = startCustomerSpecificPricingImportUsingPOSTValidateBeforeCall(channel, download, cacheFlush, quiet, importStage, null);
        Type localVarReturnType = new TypeToken<List<ImportChannelResult>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Start customer specific pricing import (asynchronously)
     * 
     * @param channel channel (optional)
     * @param download if true: causes the import file to be updated first. If no URL is stored in the FACT-Finder configuration, this parameter has no effect. (optional, default to false)
     * @param cacheFlush if true: causes a cache flush after a channel has been imported (optional, default to false)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @param importStage IMPORT_ONLY only fills the intermediate DB, LOAD_ONLY imports that database into memory, and FULL combines both stages (optional, default to FULL)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call startCustomerSpecificPricingImportUsingPOSTAsync(List<String> channel, Boolean download, Boolean cacheFlush, Boolean quiet, String importStage, final ApiCallback<List<ImportChannelResult>> _callback) throws ApiException {

        okhttp3.Call localVarCall = startCustomerSpecificPricingImportUsingPOSTValidateBeforeCall(channel, download, cacheFlush, quiet, importStage, _callback);
        Type localVarReturnType = new TypeToken<List<ImportChannelResult>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for startGeoImportUsingPOST
     * @param channel channel (optional)
     * @param download if true: causes the import file to be updated first. If no URL is stored in the FACT-Finder configuration, this parameter has no effect. (optional, default to false)
     * @param cacheFlush if true: causes a cache flush after a channel has been imported (optional, default to false)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @param importStage IMPORT_ONLY only fills the intermediate DB, LOAD_ONLY imports that database into memory, and FULL combines both stages (optional, default to FULL)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call startGeoImportUsingPOSTCall(List<String> channel, Boolean download, Boolean cacheFlush, Boolean quiet, String importStage, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v4/import/geo";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "channel", channel));
        }

        if (download != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("download", download));
        }

        if (cacheFlush != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cacheFlush", cacheFlush));
        }

        if (quiet != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("quiet", quiet));
        }

        if (importStage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("importStage", importStage));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call startGeoImportUsingPOSTValidateBeforeCall(List<String> channel, Boolean download, Boolean cacheFlush, Boolean quiet, String importStage, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = startGeoImportUsingPOSTCall(channel, download, cacheFlush, quiet, importStage, _callback);
        return localVarCall;

    }

    /**
     * Start geo import
     * 
     * @param channel channel (optional)
     * @param download if true: causes the import file to be updated first. If no URL is stored in the FACT-Finder configuration, this parameter has no effect. (optional, default to false)
     * @param cacheFlush if true: causes a cache flush after a channel has been imported (optional, default to false)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @param importStage IMPORT_ONLY only fills the intermediate DB, LOAD_ONLY imports that database into memory, and FULL combines both stages (optional, default to FULL)
     * @return List&lt;ImportChannelResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public List<ImportChannelResult> startGeoImportUsingPOST(List<String> channel, Boolean download, Boolean cacheFlush, Boolean quiet, String importStage) throws ApiException {
        ApiResponse<List<ImportChannelResult>> localVarResp = startGeoImportUsingPOSTWithHttpInfo(channel, download, cacheFlush, quiet, importStage);
        return localVarResp.getData();
    }

    /**
     * Start geo import
     * 
     * @param channel channel (optional)
     * @param download if true: causes the import file to be updated first. If no URL is stored in the FACT-Finder configuration, this parameter has no effect. (optional, default to false)
     * @param cacheFlush if true: causes a cache flush after a channel has been imported (optional, default to false)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @param importStage IMPORT_ONLY only fills the intermediate DB, LOAD_ONLY imports that database into memory, and FULL combines both stages (optional, default to FULL)
     * @return ApiResponse&lt;List&lt;ImportChannelResult&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ImportChannelResult>> startGeoImportUsingPOSTWithHttpInfo(List<String> channel, Boolean download, Boolean cacheFlush, Boolean quiet, String importStage) throws ApiException {
        okhttp3.Call localVarCall = startGeoImportUsingPOSTValidateBeforeCall(channel, download, cacheFlush, quiet, importStage, null);
        Type localVarReturnType = new TypeToken<List<ImportChannelResult>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Start geo import (asynchronously)
     * 
     * @param channel channel (optional)
     * @param download if true: causes the import file to be updated first. If no URL is stored in the FACT-Finder configuration, this parameter has no effect. (optional, default to false)
     * @param cacheFlush if true: causes a cache flush after a channel has been imported (optional, default to false)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @param importStage IMPORT_ONLY only fills the intermediate DB, LOAD_ONLY imports that database into memory, and FULL combines both stages (optional, default to FULL)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call startGeoImportUsingPOSTAsync(List<String> channel, Boolean download, Boolean cacheFlush, Boolean quiet, String importStage, final ApiCallback<List<ImportChannelResult>> _callback) throws ApiException {

        okhttp3.Call localVarCall = startGeoImportUsingPOSTValidateBeforeCall(channel, download, cacheFlush, quiet, importStage, _callback);
        Type localVarReturnType = new TypeToken<List<ImportChannelResult>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for startRankingImportUsingPOST
     * @param channel channel (optional)
     * @param cacheFlush if true: causes a cache flush after a channel has been imported (optional, default to false)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call startRankingImportUsingPOSTCall(List<String> channel, Boolean cacheFlush, Boolean quiet, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v4/import/ranking";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "channel", channel));
        }

        if (cacheFlush != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cacheFlush", cacheFlush));
        }

        if (quiet != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("quiet", quiet));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call startRankingImportUsingPOSTValidateBeforeCall(List<String> channel, Boolean cacheFlush, Boolean quiet, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = startRankingImportUsingPOSTCall(channel, cacheFlush, quiet, _callback);
        return localVarCall;

    }

    /**
     * Start ranking import
     * 
     * @param channel channel (optional)
     * @param cacheFlush if true: causes a cache flush after a channel has been imported (optional, default to false)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @return List&lt;ImportChannelResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public List<ImportChannelResult> startRankingImportUsingPOST(List<String> channel, Boolean cacheFlush, Boolean quiet) throws ApiException {
        ApiResponse<List<ImportChannelResult>> localVarResp = startRankingImportUsingPOSTWithHttpInfo(channel, cacheFlush, quiet);
        return localVarResp.getData();
    }

    /**
     * Start ranking import
     * 
     * @param channel channel (optional)
     * @param cacheFlush if true: causes a cache flush after a channel has been imported (optional, default to false)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @return ApiResponse&lt;List&lt;ImportChannelResult&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ImportChannelResult>> startRankingImportUsingPOSTWithHttpInfo(List<String> channel, Boolean cacheFlush, Boolean quiet) throws ApiException {
        okhttp3.Call localVarCall = startRankingImportUsingPOSTValidateBeforeCall(channel, cacheFlush, quiet, null);
        Type localVarReturnType = new TypeToken<List<ImportChannelResult>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Start ranking import (asynchronously)
     * 
     * @param channel channel (optional)
     * @param cacheFlush if true: causes a cache flush after a channel has been imported (optional, default to false)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call startRankingImportUsingPOSTAsync(List<String> channel, Boolean cacheFlush, Boolean quiet, final ApiCallback<List<ImportChannelResult>> _callback) throws ApiException {

        okhttp3.Call localVarCall = startRankingImportUsingPOSTValidateBeforeCall(channel, cacheFlush, quiet, _callback);
        Type localVarReturnType = new TypeToken<List<ImportChannelResult>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for startRecommendationImportUsingPOST
     * @param channel channel (optional)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call startRecommendationImportUsingPOSTCall(List<String> channel, Boolean quiet, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v4/import/recommendation";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "channel", channel));
        }

        if (quiet != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("quiet", quiet));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call startRecommendationImportUsingPOSTValidateBeforeCall(List<String> channel, Boolean quiet, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = startRecommendationImportUsingPOSTCall(channel, quiet, _callback);
        return localVarCall;

    }

    /**
     * Start recommendation import
     * 
     * @param channel channel (optional)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @return List&lt;ImportChannelResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public List<ImportChannelResult> startRecommendationImportUsingPOST(List<String> channel, Boolean quiet) throws ApiException {
        ApiResponse<List<ImportChannelResult>> localVarResp = startRecommendationImportUsingPOSTWithHttpInfo(channel, quiet);
        return localVarResp.getData();
    }

    /**
     * Start recommendation import
     * 
     * @param channel channel (optional)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @return ApiResponse&lt;List&lt;ImportChannelResult&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ImportChannelResult>> startRecommendationImportUsingPOSTWithHttpInfo(List<String> channel, Boolean quiet) throws ApiException {
        okhttp3.Call localVarCall = startRecommendationImportUsingPOSTValidateBeforeCall(channel, quiet, null);
        Type localVarReturnType = new TypeToken<List<ImportChannelResult>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Start recommendation import (asynchronously)
     * 
     * @param channel channel (optional)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call startRecommendationImportUsingPOSTAsync(List<String> channel, Boolean quiet, final ApiCallback<List<ImportChannelResult>> _callback) throws ApiException {

        okhttp3.Call localVarCall = startRecommendationImportUsingPOSTValidateBeforeCall(channel, quiet, _callback);
        Type localVarReturnType = new TypeToken<List<ImportChannelResult>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for startSearchImportUsingPOST
     * @param channel channel (optional)
     * @param download if true: causes the import file to be updated first. If no URL is stored in the FACT-Finder configuration, this parameter has no effect. (optional, default to false)
     * @param cacheFlush if true: causes a cache flush after a channel has been imported (optional, default to false)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @param importStage IMPORT_ONLY only fills the intermediate DB, LOAD_ONLY imports that database into memory, and FULL combines both stages (optional, default to FULL)
     * @param includeCustomerPrices if true: executes a customer specific pricing import after the search import. If customer specific pricing is not enabled for a given channel, this parameter has no effect. (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call startSearchImportUsingPOSTCall(List<String> channel, Boolean download, Boolean cacheFlush, Boolean quiet, String importStage, Boolean includeCustomerPrices, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v4/import/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "channel", channel));
        }

        if (download != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("download", download));
        }

        if (cacheFlush != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cacheFlush", cacheFlush));
        }

        if (quiet != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("quiet", quiet));
        }

        if (importStage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("importStage", importStage));
        }

        if (includeCustomerPrices != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeCustomerPrices", includeCustomerPrices));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call startSearchImportUsingPOSTValidateBeforeCall(List<String> channel, Boolean download, Boolean cacheFlush, Boolean quiet, String importStage, Boolean includeCustomerPrices, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = startSearchImportUsingPOSTCall(channel, download, cacheFlush, quiet, importStage, includeCustomerPrices, _callback);
        return localVarCall;

    }

    /**
     * Start search import
     * 
     * @param channel channel (optional)
     * @param download if true: causes the import file to be updated first. If no URL is stored in the FACT-Finder configuration, this parameter has no effect. (optional, default to false)
     * @param cacheFlush if true: causes a cache flush after a channel has been imported (optional, default to false)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @param importStage IMPORT_ONLY only fills the intermediate DB, LOAD_ONLY imports that database into memory, and FULL combines both stages (optional, default to FULL)
     * @param includeCustomerPrices if true: executes a customer specific pricing import after the search import. If customer specific pricing is not enabled for a given channel, this parameter has no effect. (optional, default to false)
     * @return List&lt;ImportChannelResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public List<ImportChannelResult> startSearchImportUsingPOST(List<String> channel, Boolean download, Boolean cacheFlush, Boolean quiet, String importStage, Boolean includeCustomerPrices) throws ApiException {
        ApiResponse<List<ImportChannelResult>> localVarResp = startSearchImportUsingPOSTWithHttpInfo(channel, download, cacheFlush, quiet, importStage, includeCustomerPrices);
        return localVarResp.getData();
    }

    /**
     * Start search import
     * 
     * @param channel channel (optional)
     * @param download if true: causes the import file to be updated first. If no URL is stored in the FACT-Finder configuration, this parameter has no effect. (optional, default to false)
     * @param cacheFlush if true: causes a cache flush after a channel has been imported (optional, default to false)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @param importStage IMPORT_ONLY only fills the intermediate DB, LOAD_ONLY imports that database into memory, and FULL combines both stages (optional, default to FULL)
     * @param includeCustomerPrices if true: executes a customer specific pricing import after the search import. If customer specific pricing is not enabled for a given channel, this parameter has no effect. (optional, default to false)
     * @return ApiResponse&lt;List&lt;ImportChannelResult&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ImportChannelResult>> startSearchImportUsingPOSTWithHttpInfo(List<String> channel, Boolean download, Boolean cacheFlush, Boolean quiet, String importStage, Boolean includeCustomerPrices) throws ApiException {
        okhttp3.Call localVarCall = startSearchImportUsingPOSTValidateBeforeCall(channel, download, cacheFlush, quiet, importStage, includeCustomerPrices, null);
        Type localVarReturnType = new TypeToken<List<ImportChannelResult>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Start search import (asynchronously)
     * 
     * @param channel channel (optional)
     * @param download if true: causes the import file to be updated first. If no URL is stored in the FACT-Finder configuration, this parameter has no effect. (optional, default to false)
     * @param cacheFlush if true: causes a cache flush after a channel has been imported (optional, default to false)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @param importStage IMPORT_ONLY only fills the intermediate DB, LOAD_ONLY imports that database into memory, and FULL combines both stages (optional, default to FULL)
     * @param includeCustomerPrices if true: executes a customer specific pricing import after the search import. If customer specific pricing is not enabled for a given channel, this parameter has no effect. (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call startSearchImportUsingPOSTAsync(List<String> channel, Boolean download, Boolean cacheFlush, Boolean quiet, String importStage, Boolean includeCustomerPrices, final ApiCallback<List<ImportChannelResult>> _callback) throws ApiException {

        okhttp3.Call localVarCall = startSearchImportUsingPOSTValidateBeforeCall(channel, download, cacheFlush, quiet, importStage, includeCustomerPrices, _callback);
        Type localVarReturnType = new TypeToken<List<ImportChannelResult>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for startSuggestImportUsingPOST
     * @param channel channel (optional)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call startSuggestImportUsingPOSTCall(List<String> channel, Boolean quiet, final ApiCallback _callback) throws ApiException {
        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/v4/import/suggest";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (channel != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "channel", channel));
        }

        if (quiet != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("quiet", quiet));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        String[] localVarAuthNames = new String[] { "basicAuth", "oAuth2" };
        return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call startSuggestImportUsingPOSTValidateBeforeCall(List<String> channel, Boolean quiet, final ApiCallback _callback) throws ApiException {
        

        okhttp3.Call localVarCall = startSuggestImportUsingPOSTCall(channel, quiet, _callback);
        return localVarCall;

    }

    /**
     * Start suggest import
     * 
     * @param channel channel (optional)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @return List&lt;ImportChannelResult&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public List<ImportChannelResult> startSuggestImportUsingPOST(List<String> channel, Boolean quiet) throws ApiException {
        ApiResponse<List<ImportChannelResult>> localVarResp = startSuggestImportUsingPOSTWithHttpInfo(channel, quiet);
        return localVarResp.getData();
    }

    /**
     * Start suggest import
     * 
     * @param channel channel (optional)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @return ApiResponse&lt;List&lt;ImportChannelResult&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ImportChannelResult>> startSuggestImportUsingPOSTWithHttpInfo(List<String> channel, Boolean quiet) throws ApiException {
        okhttp3.Call localVarCall = startSuggestImportUsingPOSTValidateBeforeCall(channel, quiet, null);
        Type localVarReturnType = new TypeToken<List<ImportChannelResult>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Start suggest import (asynchronously)
     * 
     * @param channel channel (optional)
     * @param quiet if true: only receive a filled response if an error occurs during the import otherwise the response is just empty (optional, default to false)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call startSuggestImportUsingPOSTAsync(List<String> channel, Boolean quiet, final ApiCallback<List<ImportChannelResult>> _callback) throws ApiException {

        okhttp3.Call localVarCall = startSuggestImportUsingPOSTValidateBeforeCall(channel, quiet, _callback);
        Type localVarReturnType = new TypeToken<List<ImportChannelResult>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
